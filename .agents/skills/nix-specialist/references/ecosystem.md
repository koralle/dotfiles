# Nixエコシステム

## 1. 目的

Nix関連ツール群と設計パターンを整理し、規模拡大時の破綻を防ぐための参照。

## 2. flake-utils

- `eachDefaultSystem` でマルチプラットフォームの出力定義を簡潔化する。
- システムごとの重複を減らし、構成の見通しを改善する。
- 小〜中規模のFlakeでは導入コストに対して効果が高い。

## 3. flake-parts

- Flakeにモジュール的な分割と合成を導入する。
- 大規模 `outputs` の責務分離に向く。
- チーム開発で役割ごとに設定を分けるときに有効。

## 4. よくある設計判断

1. 小規模なら素のFlakeで開始し、重複増加時に `flake-utils` を導入する。
2. 構成が肥大化したら `flake-parts` で責務単位に分割する。
3. NixOS/nix-darwin/Home Manager を同一リポジトリで扱う場合は境界を明示する。
4. Nixpkgsの追従方針を決め、更新粒度と検証手順を固定する。

## 5. 誤りやすい点

- 早期に抽象化しすぎて、構成理解が困難になる。
- ツール導入自体が目的化し、実際の運用要件を見失う。
- 同じ設定責務を複数箇所に重複定義する。
- Nixpkgs更新の影響範囲を把握せずに一括更新する。

## 6. ベストプラクティス

- まず素直な構成で開始し、重複や複雑性が閾値を超えてから抽象化する。
- 役割ごとにファイルを分け、インターフェースを明示する。
- 「どこに何を書くか」を短い規約として残す。
- Nixpkgs更新時は差分確認と検証をセットで運用する。

## 7. 主要参照

- `numtide/flake-utils`
- `hercules-ci/flake-parts`
- Nixpkgs Manual
- Zenn: `nix-introduction`, `nix-hands-on`
